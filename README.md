# C语言五子棋

## 编译运行方法
先新建一个名叫Bulid的文件夹，然后运行build.sh即可编译，编译出的文件为main。

## 模式选择
- AI.h中可以选择训练模式和比赛模式
- game.c开头有控制功能的选项

## 功能模块
- AI:用于计算自动落子
- game:用于控制比赛，提供比赛接口,图形化界面,裁判等功能
- main:用于整合所有功能

##  棋形判断
把一个方向上的所有子存到一个uint32_t变量中，用两位表示棋盘的一种状态,00为不可落子，11为空，01为和stdchess相同.

### 活四检测
两个点成五
活4有只有一种情况:11 01 01 01 01 11

### 冲四检测
一个点成五
冲4有以下几种情况:
- 00 01 01 01 01 11
- 11 01 01 01 01 00
- 01 01 01 11 01 xx
- 01 01 11 01 01 xx
- 01 11 01 01 01 xx

### 活三检测
一步活四
活三有以下几种情况:
- 11 01 01 01 11 11
- 11 01 01 11 01 11
- 11 01 11 01 01 11
- 11 11 01 01 01 11

### 假活三检测
假活三没有意义,既不会形成禁手,把假活三补为冲四也会被马上拦下,因此不做检测.

### 单子检测
单子有3种情况:两边空,一边空,两边堵.
两边空:11 01 11

一边空:
- 11 01 00
- 00 01 11

两边堵:00 01 00

### 双子检测
双子有6种情况:两边空,一边空,两边堵,间隔一,间隔二,间隔三(带间隔是为成5准备)

两边空: 11 01 01 11 

一边空,两边堵: 略

间隔一:11 01 11 01 11

间隔二:
- 11 01 11 11 01
- 01 11 11 01 11

间隔三:01 11 11 11 01

## 禁手判断
为应对假活三的情况,在判断活三时对空位进行递归判断.

递归清除黑子:清除这一轮刚放的.

### 同一条线上的三三禁手
不可能下一个子,在同一条线上形成2个活三.

证明如下:

采用反证法,下一个子形成了两个活三,则一定有
- 上述活三的中间11重合的情况,这样会导致两端的11和01相对应.
- 中间的11和两头的11重合,会产生无重合的三三(1+4)或假三三(2+3)

### 同一条线上的四四禁手
因为四可以是活四也可以是冲四,所以可能在同一条线上产生四四禁手.

判断时只需要在检测窗口不同时都检测到冲四或者活四,就是四四禁手.

只需要不可能出现两个四的后5位和前5位相同即可.

事实上有两个反例:
- 01 11 01 01 01 xx and 11 01 01 01 01 00
- 01 11 01 01 01 xx and 11 01 01 01 01 11

把xx改为00/11就不会出此问题

## AI

### alpha-beta剪枝
![alpha-beta](./Pics/alpha-beta.png)
我们这样解释这一颗树:
- MAX行代表AI得到的分数,MIN行代表对手的分数
- MAX到MIN的棋子是AI下的.
- 所有分数都来源于最后行的叶子节点,所以要按深度搜索.
- 事实上搜索偶数层,因为要考虑对手的防守.
- 剪枝参考:当前层已经计算出来的节点和下一层已经被计算出来的节点.
- 重点看最右边的一支,第二层前面已经计算出有一个值为6,且下一层算出了5,那么不管下一层计算出何种值,第二层最后一个数不可能大于5,根节点肯定会取到大于等于6的数,故把最右边的分支全部减掉.

#### 数学语言
对于MAX层:
$Y=\max\{a,b,c,min\{d,e,f\}\}$,
这些值依次被计算出来,如果
$d<=\max\{a,b,c\}$
则后面的$ef$不用计算.

对于MIN层:
$Y=\min\{a,b,c,\max\{d,e,f\}\}$,
这些值依次被计算出来,如果
$d=>\min\{a,b,c\}$
则后面的$ef$不用计算.